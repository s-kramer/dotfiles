#int priority -50


extends c

# # We want to overwrite everything in parent ft.
# priority -49

###########################################################################
#							TextMate Snippets							#
###########################################################################
snippet be "$1.begin(), $1.end() (beginend)" w
${1:v}${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}begin(), $1${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}end()
endsnippet

snippet cbe "$1.cbegin(), $1.cend() (cbeginend)" w
${1:v}${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}cbegin(), $1${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}cend()
endsnippet


snippet cl "class"
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
	explicit ${1/(\w+).*/$1/} (${2:arguments}) {};
	$0
private:
};
endsnippet

snippet vcl "virtual class"
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
	explicit ${1/(\w+).*/$1/} (${2:arguments}) {};
	virtual ~${1/(\w+).*/$1/} () {};
	$0
private:
	${1/(\w+).*/$1/} (const ${1/(\w+).*/$1/}&);
	${1/(\w+).*/$1/} operator=(const ${1/(\w+).*/$1/}&);
};
endsnippet

snippet fun "function declaration"
${2: /* type */} ${1: /* fcn name */} (${3:/* args */})
{
	$0
}
endsnippet

snippet ns "namespace .. (namespace)"
namespace${1/.+/ /m}${1:`!p snip.rv = snip.basename or "name"`}
{
	$0
}${1/.+/ \/* /m}$1${1/.+/ *\/ /m}
endsnippet

snippet readfile "read file (readF)"
std::vector<char> v;
if (FILE *fp = fopen(${1:"filename"}, "r"))
{
	char buf[${2:1024}];
	while(size_t len = fread(buf, 1, sizeof(buf), fp))
				v.push_back(buf);
	fclose(fp);
}
endsnippet

snippet map "std::map (map)"
std::map<${1:key}, ${2:value}> map$0;
endsnippet

snippet v "std::vector (v)"
std::vector<${1:char}> ${2:name};$0
endsnippet

snippet tp "template <typename ..> (template)"
template <typename ${1:_InputIter}>
endsnippet

snippet try "try catch "
try {
	${1:/* code */}
}
catch (${2:exceptionType}) {
	${3:/* code */}
}
$0
endsnippet

snippet catch "additional catch"
catch (${1:/* exceptionType /*}) {
	${2:/* code */}
}
$0
endsnippet

snippet inv "#include <vector>" !b
#include <vector>
$0
endsnippet

snippet ini "#include <iostream>" !b
#include <iostream>
$0
endsnippet

snippet inb "Include boost" !b
#include <boost/$1>$0
endsnippet

snippet inbfe "Include BOOST_FOREACH" !b
#include <boost/foreach.hpp>
#define  foreach_ BOOST_FOREACH
endsnippet

snippet bfe "boost::foreach" !b
boost::for_each(${1:/*range/*}, ${2:/*fcn*/});$0
endsnippet

snippet BFE "BOOST_FOREACH" !b
foreach_(${1:int} ${2:i}, ${3:/*range*/})
{
	$4
}$0
endsnippet

snippet co "std::cout" !b
std::cout << $1;$0
endsnippet

snippet con "std::cout '\n'" !b
std::cout << $1 << '\n';$0
endsnippet

snippet cn "'\n'" w
<< '\n';$0
endsnippet

snippet ins "Include standards" !b
#include <iostream>
#include <boost/$1>
#include <${2:vector}>

$3

int main()
{
	$0
	return 0;
}

endsnippet

snippet gt "gtest"
TEST(${1:test_case_name}, ${2:test_name})
{
	${3:test_body}
}
endsnippet

snippet gf "gtest with fixture"
TEST_F(${1:fixture_name}, ${2:test_name})
{
	${3:test_body}
}
endsnippet

snippet forc "Container for"
for(${1:container}::${2:const_iterator} it = ${3:cont_name}.begin(); it != $3.end(); ++it)
{
	${0:/*code*/}
}
endsnippet

snippet oi "std::ostream_iterator"
std::ostream_iterator<${1:int}>(${2:std::cout}, "\n")
endsnippet

snippet bt "Boost auto test case" b
BOOST_AUTO_TEST_CASE(${1:unitOfWork}_${2:scenario}_${3:result})
{
	${4:arrange}

	${5:act}

	${6:assert}
}
endsnippet

snippet bf "Boost fixture test case" b
BOOST_FIXTURE_TEST_CASE(${1:unitOfWork}_${2:scenario}_${3:result}, ${4:fixture_name})
{
	${5:arrange}

	${6:act}

	${7:assert}
}

endsnippet

snippet sfor "short for loop" b
for(${1:auto} ${2:var} : ${3:container})
{
	$0;
}
endsnippet

snippet forr "for loop over container" b
for(${1:std::vector}<${2:type}>::iterator ${3:it} = ${4:container}.begin(), ${5:end} = $4.end(); $3 != $5; ++$3)
{
	$0;
}
endsnippet

snippet bce "boost check equal" b
BOOST_CHECK_EQUAL(${1:expected}, ${2:actual});
endsnippet

# vim:ft=snippets:
#

